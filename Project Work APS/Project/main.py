import os
import json
import uuid # Importa uuid per generare ID unici
from datetime import datetime
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.exceptions import InvalidSignature
import base64

# Import delle classi fornite
from Student import Student # Ora importiamo la classe Student esterna
from UniversitySalerno import UniversitySalerno
from UniversityRennes import UniversityRennes


BASE_DIR = os.path.dirname(__file__)
CRED_FOLDER = os.path.join(BASE_DIR, "credential")
os.makedirs(CRED_FOLDER, exist_ok=True)


def pre_game():
    """
    Handles the initial authentication or registration phase for the student with the University of Salerno.
    Implements a password retry mechanism and a registration flow.
    """
    print("==== [ UNIVERSITÀ DI SALERNO ] ====")
    university = UniversitySalerno()

    print("\n==== [ LOGIN O REGISTRAZIONE STUDENTE ] ====")
    username = input("Inserisci username: ").strip()
    password = input("Inserisci password: ").strip()

    student_obj = None
    current_student_id = None

    # 1. Try to authenticate the student
    user_data = university.authenticate_student(username, password)

    if not user_data:
        # User not found or incorrect password
        print("Utente non trovato o password errata.")
        register_choice = input("Vuoi registrarti? (s/n): ").strip().lower()

        if register_choice == 's':
            print("\n==== [ REGISTRAZIONE NUOVO STUDENTE ] ====")
            first_name = input("Inserisci il tuo nome: ").strip()
            last_name = input("Inserisci il tuo cognome: ").strip()

            # Generate unique ID for the new user
            user_id = str(uuid.uuid4())

            # Create the Student object. This object WILL GENERATE keys and DID for the first time.
            student_obj = Student(username=username, password=password, user_id=user_id,
                                  first_name=first_name, last_name=last_name)

            # Register the student in the university's DB, saving their ID, username, HASHED password,
            # first name, last name, and the PUBLIC KEY generated by the student.
            success = university.register_student(user_id, username, password, first_name, last_name,
                                                  student_obj.get_public_key())

            if not success:
                print("❌ Errore durante la registrazione nel DB dell'università.")
                return None, None

            # Update their DID in the university's DB (if not already done in register_student)
            # This ensures the university has the correct DID associated with the user ID.
            university.assign_did_to_student(user_id, student_obj.did,
                                             student_obj.get_public_key())

            print(f"✅ Utente '{username}' registrato con successo e DID: {student_obj.did}")
            current_student_id = user_id
            # Since just registered, consider authentication successful to proceed.
            user_data = university.user_manager.get_user_by_id(current_student_id) # Reload complete user data
        else:
            print("Accesso negato.")
            return None, None
    else:
        # Authentication successful for existing user
        print("✅ Autenticazione riuscita.")
        current_student_id = user_data["id"]

        # Re-create the Student object for existing user.
        student_obj = Student(
            username=username,
            password=password,user_id=current_student_id,
            first_name=user_data.get("first_name"),
            last_name=user_data.get("last_name")
        )
        # Ensure the Student object's DID is the one retrieved from the university's DB
        student_obj.did = user_data.get("did")


    # If we reached here, the student is authenticated or just registered
    if not student_obj: # Should always be True at this point, but for safety
        print("Errore interno: Oggetto studente non creato correttamente.")
        return None, None

    print("\n==== [ VERIFICA DID STUDENTE (dopo Auth/Registrazione, prima del Challenge-Response) ] ====")

    # Simulation: The student "sends" their DID to the university
    student_did_from_client = student_obj.did
    print(f"Studente (simulazione): Invio il mio DID: {student_did_from_client}")

    # The university "receives" the DID from the student and compares it with its DB
    did_from_university_db = user_data.get("did")

    if student_did_from_client == did_from_university_db:
        print("Università: DID dello studente ricevuto e corrisponde a quello nel nostro database. Proseguo.")
    else:
        print("Università: ATTENZIONE! DID dello studente inviato non corrisponde al nostro database.")
        print(f"  DID da Cliente: {student_did_from_client}")
        print(f"  DID da DB Università: {did_from_university_db}")
        print("Autenticazione DID fallita. Accesso negato.")
        return None, None

    print("\n==== [ CHALLENGE-RESPONSE ] ====")

    # University generates a challenge for the student, using the authenticated ID.
    challenge = university.generate_challenge(current_student_id)
    if not challenge:
        print("❌ Errore: Impossibile generare challenge per l'utente autenticato.")
        return None, None

    print(f"Challenge generato: {challenge}")

    # The student signs the challenge with their OWN private key
    signature = student_obj.sign(challenge)
    print(f"Firma generata: {signature[:32]}...")

    # The university verifies the challenge signature.
    verification = university.verify_challenge_response(
        user_id=current_student_id,
        signature_b64=signature
    )

    if verification["status"] == "ok":
        print("✅ Verifica Challenge-Response riuscita.")
    else:
        print(f"❌ Verifica fallita: {verification['message']}")
        return None, None

    return student_obj, university # Return the objects for subsequent phases


def request_erasmus_credential_from_unisa(student_obj, university_salerno):
    """
    Allows the student to request an Erasmus eligibility credential from the University of Salerno.
    """
    print("\n==== [ RICHIESTA CREDENZIALE ERASMUS A UNISA ] ====")
    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile richiedere la credenziale Erasmus.")
        return

    print(f"Studente: Richiedo la credenziale di eligibilità Erasmus all'Università di Salerno per {student_obj.username}.")
    university_salerno.generate_erasmus_credential(student_obj)
    print("✅ Richiesta credenziale Erasmus completata. Controlla la cartella 'credential'.")


def rennes_interaction(student_obj):
    print("\n==== [ UNIVERSITÉ DE RENNES ] ====")
    university_rennes = UniversityRennes()

    # Recupero DID università Rennes e verifica trusted DID come ora
    try:
        rennes_did_doc = university_rennes.resolve_did("did:web:rennes.it")
        rennes_did = rennes_did_doc["id"]
        print(f"Studente: Ho recuperato il DID dell'Università di Rennes: {rennes_did}")
    except Exception as e:
        print(f"Errore nel recupero DID Rennes: {e}")
        return

    if rennes_did not in student_obj.get_trusted_dids():
        print(f"❌ Il DID di Rennes ({rennes_did}) non è nella mia lista di DID trusted. Interrompo.")
        return
    print(f"✅ Il DID di Rennes ({rennes_did}) è nella mia lista di DID trusted.")

    # Qui gestiamo la registrazione / autenticazione con Rennes

    # Chiedo username e password per Rennes (potrebbero essere anche email o altra info)
    username = input("Inserisci username per Università di Rennes: ").strip()
    password = input("Inserisci password per Università di Rennes: ").strip()

    user_data = university_rennes.authenticate_student(username, password)

    if not user_data:
        # Utente non registrato: chiedo se vuole registrarsi
        print("Utente non trovato o password errata.")
        register_choice = input("Vuoi registrarti a Rennes? (s/n): ").strip().lower()
        if register_choice != 's':
            print("Accesso negato.")
            return

        # Registrazione studente Rennes
        print("\n==== [ REGISTRAZIONE NUOVO STUDENTE A RENNES ] ====")
        first_name = input("Inserisci il tuo nome: ").strip()
        last_name = input("Inserisci il tuo cognome: ").strip()
        user_id = str(uuid.uuid4())

        # Creo oggetto studente specifico per Rennes, genera DID e chiavi
        student_rennes_obj = Student(username=username, password=password,user_id=user_id,
                                     first_name=first_name, last_name=last_name)

        # Registro studente in DB Rennes (ID, username, hashed password, dati e chiave pubblica)
        success = university_rennes.register_student(user_id, username, password,
                                                     first_name, last_name,
                                                     student_rennes_obj.get_public_key())

        if not success:
            print("Errore durante la registrazione nel DB di Rennes.")
            return

        # Assegno DID e chiave pubblica nel DB Rennes
        university_rennes.assign_did_to_student(user_id, student_rennes_obj.did,
                                                student_rennes_obj.get_public_key())

        # Challenge-response per validare autenticità
        challenge = university_rennes.generate_challenge(user_id)
        if not challenge:
            print("Errore generazione challenge per nuovo studente.")
            return

        print(f"Challenge generato: {challenge}")
        signature = student_rennes_obj.sign(challenge)
        print(f"Firma generata: {signature[:32]}...")

        verification = university_rennes.verify_challenge_response(user_id, signature)
        if verification["status"] != "ok":
            print(f"Verifica challenge-response fallita: {verification['message']}")
            return

        print("✅ Registrazione e challenge-response completati con successo.")
        user_data = university_rennes.user_manager.get_user_by_id(user_id)
        # Aggiorno l'oggetto student_obj con i dati Rennes se serve

    else:
        # Autenticazione esistente, creazione oggetto Student Rennes
        print("✅ Autenticazione a Rennes riuscita.")
        user_id = user_data["id"]

        student_rennes_obj = Student(username=username, password=password,user_id=user_id,
                                     first_name=user_data.get("first_name"),
                                     last_name=user_data.get("last_name"))
        student_rennes_obj.did = user_data.get("did")

        # Genero challenge-response anche qui
        challenge = university_rennes.generate_challenge(user_id)
        if not challenge:
            print("Errore generazione challenge per utente esistente.")
            return

        print(f"Challenge generato: {challenge}")
        signature = student_rennes_obj.sign(challenge)
        print(f"Firma generata: {signature[:32]}...")

        verification = university_rennes.verify_challenge_response(user_id, signature)
        if verification["status"] != "ok":
            print(f"Verifica challenge-response fallita: {verification['message']}")
            return

        print("✅ Challenge-response superato.")

    # A questo punto lo studente è autenticato e validato a Rennes
    # Prosegui con la fase di invio credenziale Erasmus e tutto il resto

    print("\nInvio credenziale Erasmus all'Università di Rennes...")

    erasmus_cred = student_obj.load_erasmus_credential()
    if not erasmus_cred:
        print("Credenziale Erasmus non trovata. Richiedere prima a UniSA.")
        return

    if not university_rennes.verify_erasmus_credential(erasmus_cred):
        print("Credenziale Erasmus NON valida. Operazione interrotta.")
        return

    print("Credenziale Erasmus verificata correttamente da Rennes.")

    exams = university_rennes.collect_exam_data()
    if not exams:
        print("Nessun esame disponibile per la credenziale accademica.")
        return

    university_rennes.generate_academic_credential(student_obj, exams)
    print("Credenziale Accademica emessa.")

    print("\nGenerazione presentazione selettiva da parte dello studente...")
    student_obj.generate_selective_presentation_from_terminal()


def verify_presentation_at_origin_university(student_obj, university_salerno):
    """
    Handles the verification of a selective presentation by the University of Salerno.
    """
    print("\n==== [ UNIVERSITÀ DI SALERNO - VERIFICA PRESENTATION ] ====")

    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile procedere con la verifica della presentazione.")
        return

    # The student loads their Verifiable Presentation
    path = os.path.join(CRED_FOLDER, f"{student_obj.username}_vp.json")
    try:
        with open(path, "r") as f:
            presentation = json.load(f)
        print(f"Studente: Ho caricato la mia presentazione da {path}.")
    except FileNotFoundError:
        print("❌ Presentazione non trovata. Assicurati di averla generata prima.")
        return
    except json.JSONDecodeError:
        print("❌ Errore di parsing della presentazione.")
        return

    # The University of Salerno verifies the presentation
    print("\nUniversità di Salerno: Ricevuta presentazione. Avvio la verifica...")
    result = university_salerno.verify_selective_presentation(presentation)
    if result:
        print("✅ Presentazione verificata correttamente dall'Università di Salerno.")
    else:
        print("❌ Presentazione NON valida per l'Università di Salerno.")

if __name__ == "__main__":
    # The pre_game phase now returns the authenticated student and university object
    authenticated_student, salerno_university = pre_game()

    if authenticated_student:
        print("\n==== FASE PRE GAME COMPLETATA ====")
        while True:
            print("\n==== [ MENU PRINCIPALE ] ====")
            print("1. Esci")
            print("2. Richiedi credenziale Erasmus a UniSA")
            print("3. Interagisci con Università di Rennes (Richiedi Attestazione Voti)")
            print("4. Presenta Verifiable Presentation (VP) all'Università di Salerno")
            choice = input("Seleziona un'opzione: ").strip()

            if choice == "1":
                break
            elif choice == "2":
                request_erasmus_credential_from_unisa(authenticated_student, salerno_university)
            elif choice == "3":
                rennes_interaction(authenticated_student)
            elif choice == "4":
                verify_presentation_at_origin_university(authenticated_student, salerno_university)
            else:
                print("Opzione non valida.")
    else:
        print("\nImpossibile procedere. Autenticazione iniziale fallita.")
