import os
import json
import uuid
from Student import Student # Assicurati che Student.py sia nel PATH
from UniversitySalerno import UniversitySalerno
from UniversityRennes import UniversityRennes


BASE_DIR = os.path.dirname(__file__)
CRED_FOLDER = os.path.join(BASE_DIR, "credential")
os.makedirs(CRED_FOLDER, exist_ok=True)


# Le funzioni ora riceveranno gli oggetti come argomenti
def pre_game(university_salerno: UniversitySalerno):
    """
    Handles the initial authentication or registration phase for the student with the University of Salerno.
    Implements a password retry mechanism and a registration flow.
    Returns the authenticated Student object or None if authentication/registration fails.
    """
    print("==== [ UNIVERSITÀ DI SALERNO ] ====")

    print("\n==== [ LOGIN O REGISTRAZIONE STUDENTE ] ====")
    username = input("Inserisci username: ").strip()
    password = input("Inserisci password: ").strip()

    # 1. Try to authenticate the student
    user_data = university_salerno.authenticate_student(username, password)

    if not user_data:
        # User not found or incorrect password
        print("Utente non trovato o password errata.")
        register_choice = input("Vuoi registrarti? (s/n): ").strip().lower()

        if register_choice == 's':
            print("\n==== [ REGISTRAZIONE NUOVO STUDENTE ] ====")
            first_name = input("Inserisci il tuo nome: ").strip()
            last_name = input("Inserisci il tuo cognome: ").strip()

            # Generate unique ID for the new user
            user_id = str(uuid.uuid4())

            # Create the Student object. This object WILL GENERATE keys and DID for the first time
            # if they don't exist for this user_id/username.
            student_obj = Student(username=username, password=password, user_id=user_id,
                                  first_name=first_name, last_name=last_name)

            # Register the student in the university's DB, saving their ID, username, HASHED password,
            # first name, last name, and the PUBLIC KEY generated by the student.
            success = university_salerno.register_student(user_id, username, password, first_name, last_name,
                                                          student_obj.get_public_key())

            if not success:
                print("❌ Errore durante la registrazione nel DB dell'università.")
                return None

            # Update their DID in the university's DB (if not already done in register_student)
            # This ensures the university has the correct DID associated with the user ID.
            university_salerno.assign_did_to_student(user_id, student_obj.did,
                                                     student_obj.get_public_key())

            print(f"✅ Utente '{username}' registrato con successo e DID: {student_obj.did}")
            current_student_id = user_id
            # Since just registered, consider authentication successful to proceed.
            user_data = university_salerno.user_manager.get_user_by_id(current_student_id) # Reload complete user data
        else:
            print("Accesso negato.")
            return None
    else:
        # Authentication successful for existing user
        print("✅ Autenticazione riuscita.")
        current_student_id = user_data["id"]

        # Re-create the Student object for existing user, which will load existing keys/DID.
        student_obj = Student(
            username=username,
            password=password,
            user_id=current_student_id,
            first_name=user_data.get("first_name"),
            last_name=user_data.get("last_name")
        )
        # Ensure the Student object's DID is the one retrieved from the university's DB
        student_obj.did = user_data.get("did")


    # If we reached here, the student is authenticated or just registered
    if not student_obj: # Should always be True at this point, but for safety
        print("Errore interno: Oggetto studente non creato correttamente.")
        return None

    print("\n==== [ VERIFICA DID STUDENTE (dopo Auth/Registrazione, prima del Challenge-Response) ] ====")

    # Simulation: The student "sends" their DID to the university
    student_did_from_client = student_obj.did
    print(f"Studente (simulazione): Invio il mio DID: {student_did_from_client}")

    # The university "receives" the DID from the student and compares it with its DB
    did_from_university_db = user_data.get("did")

    if student_did_from_client == did_from_university_db:
        print("Università: DID dello studente ricevuto e corrisponde a quello nel nostro database. Proseguo.")
    else:
        print("Università: ATTENZIONE! DID dello studente inviato non corrisponde al nostro database.")
        print(f" DID da Cliente: {student_did_from_client}")
        print(f" DID da DB Università: {did_from_university_db}")
        print("Autenticazione DID fallita. Accesso negato.")
        return None

    print("\n==== [ CHALLENGE-RESPONSE ] ====")

    # University generates a challenge for the student, using the authenticated ID.
    challenge = university_salerno.generate_challenge(current_student_id)
    if not challenge:
        print("❌ Errore: Impossibile generare challenge per l'utente autenticato.")
        return None

    print(f"Challenge generato: {challenge}")

    # The student signs the challenge with their OWN private key
    signature = student_obj.sign(challenge)
    print(f"Firma generata: {signature[:32]}...")

    # The university verifies the challenge signature.
    verification = university_salerno.verify_challenge_response(
        user_id=current_student_id,
        signature_b64=signature
    )

    if verification["status"] == "ok":
        print("✅ Verifica Challenge-Response riuscita.")
        return student_obj # Ritorna l'oggetto Student autenticato
    else:
        print(f"❌ Verifica fallita: {verification['message']}")
        return None


def request_erasmus_credential_from_unisa(student_obj: Student, university_salerno: UniversitySalerno):
    """
    Allows the student to request an Erasmus eligibility credential from the University of Salerno.
    """
    print("\n==== [ RICHIESTA CREDENZIALE ERASMUS A UNISA ] ====")
    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile richiedere la credenziale Erasmus.")
        return

    print(f"Studente: Richiedo la credenziale di eligibilità Erasmus all'Università di Salerno per {student_obj.username}.")
    university_salerno.generate_erasmus_credential(student_obj)
    print("✅ Richiesta credenziale Erasmus completata. Controlla la cartella 'credential'.")


def rennes_interaction(student_obj: Student, university_rennes: UniversityRennes, university_salerno: UniversitySalerno):
    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile interagire con Rennes.")
        return

    print("\n==== [ UNIVERSITÉ DE RENNES ] ====")

    # Recupero DID università Rennes e verifica trusted DID
    try:
        rennes_did_doc = university_rennes.resolve_did("did:web:rennes.it")
        rennes_did = rennes_did_doc["id"]
        print(f"Studente: Ho recuperato il DID dell'Università di Rennes: {rennes_did}")
    except Exception as e:
        print(f"Errore nel recupero DID Rennes: {e}")
        return

    # Il controllo se il DID di Rennes è nella lista trusted dello studente.
    if rennes_did not in student_obj.get_trusted_dids():
        print(f"❌ Il DID di Rennes ({rennes_did}) non è nella mia lista di DID trusted. Interrompo.")
        return
    print(f"✅ Il DID di Rennes ({rennes_did}) è nella mia lista di DID trusted.")


    # Qui gestiamo la registrazione / autenticazione con Rennes
    print("\n==== [ LOGIN O REGISTRAZIONE STUDENTE A RENNES ] ====")
    username = input("Inserisci username per Università di Rennes: ").strip()
    password = input("Inserisci password per Università di Rennes: ").strip()

    user_data = university_rennes.authenticate_student(username, password)

    if not user_data:
        print("Utente non trovato o password errata nell'Università di Rennes.")
        register_choice = input("Vuoi registrarti a Rennes? (s/n): ").strip().lower()
        if register_choice != 's':
            print("Accesso negato a Rennes.")
            return

        print("\n==== [ REGISTRAZIONE STUDENTE ESISTENTE A RENNES ] ====")
        user_id_for_rennes = student_obj.user_id # L'ID dello studente principale
        first_name = student_obj.first_name
        last_name = student_obj.last_name

        success = university_rennes.register_student(user_id_for_rennes, username, password,
                                                     first_name, last_name,
                                                     student_obj.get_public_key()) # Usa la chiave pubblica dello studente principale

        if not success:
            print("❌ Errore durante la registrazione nel DB di Rennes.")
            return

        university_rennes.assign_did_to_student(user_id_for_rennes, student_obj.did,
                                                 student_obj.get_public_key())

        print("✅ Registrazione a Rennes completata. Ora procedo con il challenge-response per la verifica.")
    else:
        print("✅ Autenticazione a Rennes riuscita.")
        user_id_for_rennes = user_data["id"]
        if user_id_for_rennes != student_obj.user_id:
            print("⚠️ Attenzione: L'ID utente a Rennes non corrisponde all'ID dello studente attualmente autenticato.")
            print("Si procederà con l'ID di Rennes per le operazioni, ma questo potrebbe indicare un'incoerenza.")

    # Genero challenge-response con Rennes
    print("\n==== [ CHALLENGE-RESPONSE CON RENNES ] ====")
    challenge = university_rennes.generate_challenge(user_id_for_rennes)
    if not challenge:
        print("❌ Errore generazione challenge per utente Rennes.")
        return

    print(f"Challenge generato: {challenge}")
    signature = student_obj.sign(challenge) # Lo studente autenticato firma il challenge di Rennes
    print(f"Firma generata: {signature[:32]}...")

    verification = university_rennes.verify_challenge_response(user_id_for_rennes, signature)
    if verification["status"] != "ok":
        print(f"❌ Verifica challenge-response fallita con Rennes: {verification['message']}")
        return

    print("✅ Challenge-response superato con Rennes.")

    print("\nInvio credenziale Erasmus all'Università di Rennes...")

    erasmus_cred = student_obj.load_erasmus_credential()
    if not erasmus_cred:
        print("Credenziale Erasmus non trovata. Richiedere prima a UniSA.")
        return

    if not university_rennes.verify_erasmus_credential(erasmus_cred):
        print("❌ Credenziale Erasmus NON valida. Invio Comunicazione di Revoca a Salerno.")
        university_salerno.revocate_credential(erasmus_cred)
        return

    print("✅ Credenziale Erasmus verificata correttamente da Rennes.")

    exams = university_rennes.collect_exam_data("exams.json")
    if not exams:
        print("Nessun esame disponibile per la credenziale accademica.")
        return

    university_rennes.generate_academic_credential(student_obj, exams)
    print("✅ Credenziale Accademica emessa da Rennes.")

    print("\nGenerazione presentazione selettiva da parte dello studente...")
    student_obj.generate_selective_presentation_from_terminal()


def verify_presentation_at_origin_university(student_obj: Student, university_salerno: UniversitySalerno, university_rennes: UniversityRennes):
    """
    Handles the verification of a selective presentation by the University of Salerno.
    """
    print("\n==== [ UNIVERSITÀ DI SALERNO - VERIFICA PRESENTATION ] ====")

    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile procedere con la verifica della presentazione.")
        return

    # The student loads their Verifiable Presentation
    path = os.path.join(CRED_FOLDER, f"{student_obj.username}_vp.json")
    try:
        with open(path, "r") as f:
            presentation = json.load(f)
        print(f"Studente: Ho caricato la mia presentazione da {path}.")
    except FileNotFoundError:
        print("❌ Presentazione non trovata. Assicurati di averla generata prima.")
        return
    except json.JSONDecodeError:
        print("❌ Errore di parsing della presentazione.")
        return

    # The University of Salerno verifies the presentation
    print("\nUniversità di Salerno: Ricevuta presentazione. Avvio la verifica...")
    # Qui si assume che verify_selective_presentation accetti solo la presentazione.
    # Se ha bisogno di chiavi pubbliche di emittenti (come Rennes), queste devono essere ottenute
    # dalla UniversitySalerno stessa tramite il suo meccanismo di risoluzione DID o trusted DIDs.
    # Non aggiungo parametri qui che non fossero esplicitamente richiesti dalla firma originale.
    result = university_salerno.verify_selective_presentation(presentation)
    if result:
        print("✅ Presentazione verificata correttamente dall'Università di Salerno.")
    else:
        print("❌ Presentazione NON valida per l'Università di Salerno. Invio comunicazione di revoca a Rennes.")
        university_rennes.revocate_credential(presentation)

if __name__ == "__main__":
    # Inizializzazione delle UNICHE istanze delle università
    salerno_university = UniversitySalerno()
    rennes_university = UniversityRennes()

    # La fase pre_game ora riceve l'istanza di UniSA e restituisce l'oggetto studente autenticato
    authenticated_student = pre_game(salerno_university)

    if authenticated_student:
        print("\n==== FASE PRE GAME COMPLETATA ====")
        while True:
            print("\n==== [ MENU PRINCIPALE ] ====")
            print("1. Esci")
            print("2. Richiedi credenziale Erasmus a UniSA")
            print("3. Interagisci con Università di Rennes (Richiedi Attestazione Voti)")
            print("4. Presenta Verifiable Presentation (VP) all'Università di Salerno")
            choice = input("Seleziona un'opzione: ").strip()

            if choice == "1":
                break
            elif choice == "2":
                request_erasmus_credential_from_unisa(authenticated_student, salerno_university)
            elif choice == "3":
                rennes_interaction(authenticated_student, rennes_university, salerno_university)
            elif choice == "4":
                verify_presentation_at_origin_university(authenticated_student, salerno_university, rennes_university)
            else:
                print("Opzione non valida.")
    else:
        print("\nImpossibile procedere. Autenticazione iniziale fallita.")