import os
import json
import uuid # Importa uuid per generare ID unici
from datetime import datetime
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.exceptions import InvalidSignature
import base64

# Import delle classi fornite
from Student import Student # Ora importiamo la classe Student esterna
from UniversitySalerno import UniversitySalerno
from UniversityRennes import UniversityRennes
# Assumendo che PasswordManager sia disponibile e funzioni correttamente
# from PasswordManager import PasswordManager

BASE_DIR = os.path.dirname(__file__)
CRED_FOLDER = os.path.join(BASE_DIR, "credential")
os.makedirs(CRED_FOLDER, exist_ok=True)


def pre_game():
    """
    Handles the initial authentication or registration phase for the student with the University of Salerno.
    Implements a password retry mechanism and a registration flow.
    """
    print("==== [ UNIVERSITÀ DI SALERNO ] ====")
    university = UniversitySalerno()

    print("\n==== [ LOGIN O REGISTRAZIONE STUDENTE ] ====")
    username = input("Inserisci username: ").strip()
    password = input("Inserisci password: ").strip()

    student_obj = None
    current_student_id = None

    # 1. Try to authenticate the student
    user_data = university.authenticate_student(username, password)

    if not user_data:
        # User not found or incorrect password
        print("Utente non trovato o password errata.")
        register_choice = input("Vuoi registrarti? (s/n): ").strip().lower()

        if register_choice == 's':
            print("\n==== [ REGISTRAZIONE NUOVO STUDENTE ] ====")
            first_name = input("Inserisci il tuo nome: ").strip()
            last_name = input("Inserisci il tuo cognome: ").strip()

            # Generate unique ID for the new user
            user_id = str(uuid.uuid4())

            # Create the Student object. This object WILL GENERATE keys and DID for the first time.
            student_obj = Student(username=username, password=password,
                                  first_name=first_name, last_name=last_name)

            # Register the student in the university's DB, saving their ID, username, HASHED password,
            # first name, last name, and the PUBLIC KEY generated by the student.
            success = university.register_student(user_id, username, password, first_name, last_name,
                                                  student_obj.get_public_key())

            if not success:
                print("❌ Errore durante la registrazione nel DB dell'università.")
                return None, None

            # Update their DID in the university's DB (if not already done in register_student)
            # This ensures the university has the correct DID associated with the user ID.
            university.assign_did_to_student(user_id, student_obj.did,
                                             student_obj.get_public_key())

            print(f"✅ Utente '{username}' registrato con successo e DID: {student_obj.did}")
            current_student_id = user_id
            # Since just registered, consider authentication successful to proceed.
            user_data = university.user_manager.get_user_by_id(current_student_id) # Reload complete user data
        else:
            print("Accesso negato.")
            return None, None
    else:
        # Authentication successful for existing user
        print("✅ Autenticazione riuscita.")
        current_student_id = user_data["id"]

        # Re-create the Student object for existing user.
        student_obj = Student(
            username=username,
            password=password,
            first_name=user_data.get("first_name"),
            last_name=user_data.get("last_name")
        )
        # Ensure the Student object's DID is the one retrieved from the university's DB
        student_obj.did = user_data.get("did")


    # If we reached here, the student is authenticated or just registered
    if not student_obj: # Should always be True at this point, but for safety
        print("Errore interno: Oggetto studente non creato correttamente.")
        return None, None

    print("\n==== [ VERIFICA DID STUDENTE (dopo Auth/Registrazione, prima del Challenge-Response) ] ====")

    # Simulation: The student "sends" their DID to the university
    student_did_from_client = student_obj.did
    print(f"Studente (simulazione): Invio il mio DID: {student_did_from_client}")

    # The university "receives" the DID from the student and compares it with its DB
    did_from_university_db = user_data.get("did")

    if student_did_from_client == did_from_university_db:
        print("Università: DID dello studente ricevuto e corrisponde a quello nel nostro database. Proseguo.")
    else:
        print("Università: ATTENZIONE! DID dello studente inviato non corrisponde al nostro database.")
        print(f"  DID da Cliente: {student_did_from_client}")
        print(f"  DID da DB Università: {did_from_university_db}")
        print("Autenticazione DID fallita. Accesso negato.")
        return None, None

    print("\n==== [ CHALLENGE-RESPONSE ] ====")

    # University generates a challenge for the student, using the authenticated ID.
    challenge = university.generate_challenge(current_student_id)
    if not challenge:
        print("❌ Errore: Impossibile generare challenge per l'utente autenticato.")
        return None, None

    print(f"Challenge generato: {challenge}")

    # The student signs the challenge with their OWN private key
    signature = student_obj.sign(challenge)
    print(f"Firma generata: {signature[:32]}...")

    # The university verifies the challenge signature.
    verification = university.verify_challenge_response(
        user_id=current_student_id,
        signature_b64=signature
    )

    if verification["status"] == "ok":
        print("✅ Verifica Challenge-Response riuscita.")
    else:
        print(f"❌ Verifica fallita: {verification['message']}")
        return None, None

    return student_obj, university # Return the objects for subsequent phases


def request_erasmus_credential_from_unisa(student_obj, university_salerno):
    """
    Allows the student to request an Erasmus eligibility credential from the University of Salerno.
    """
    print("\n==== [ RICHIESTA CREDENZIALE ERASMUS A UNISA ] ====")
    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile richiedere la credenziale Erasmus.")
        return

    print(f"Studente: Richiedo la credenziale di eligibilità Erasmus all'Università di Salerno per {student_obj.username}.")
    university_salerno.generate_erasmus_credential(student_obj)
    print("✅ Richiesta credenziale Erasmus completata. Controlla la cartella 'credential'.")


def rennes_interaction(student_obj):
    """
    Handles the student's interaction with the University of Rennes.
    Includes simulated authentication, sending and verifying the Erasmus credential,
    and issuing the academic credential.
    """
    print("\n==== [ UNIVERSITÉ DE RENNES ] ====")
    university_rennes = UniversityRennes()

    # The student retrieves the DID of the University of Rennes
    try:
        rennes_did_doc = university_rennes.resolve_did("did:web:rennes.it")
        rennes_did = rennes_did_doc["id"]
        print(f"Studente: Ho recuperato il DID dell'Università di Rennes: {rennes_did}")
    except Exception as e:
        print(f"Studente: Errore nel recupero del DID di Rennes: {e}")
        return

    # Check if Rennes's DID is in the student's wallet's trusted DIDs list
    if rennes_did not in student_obj.get_trusted_dids():
        print(f"Studente: ❌ Il DID di Rennes ({rennes_did}) NON è nella mia lista di DID trusted. Interrompo.")
        return
    print(f"Studente: ✅ Il DID di Rennes ({rennes_did}) è nella mia lista di DID trusted.")

    # Simulation of student authentication with username and password at Rennes.
    print(f"\nStudente: Tentativo di autenticazione con username '{student_obj.username}' a Rennes...")
    # In a real scenario, Rennes would have its own authentication system.
    # Here, as per the request, we assume that if the student_obj is valid, authentication is "successful".
    if student_obj:
        print(f"Studente: ✅ Autenticazione simulata a Rennes riuscita per {student_obj.username}.")
    else:
        print("Studente: ❌ Autenticazione simulata a Rennes fallita. Oggetto studente non valido.")
        return

    # The student sends the Erasmus eligibility credential
    print("\nStudente: Invio la mia credenziale di eligibilità Erasmus all'Università di Rennes.")
    erasmus_cred = student_obj.load_erasmus_credential()
    if not erasmus_cred:
        print("Studente: ❌ Impossibile inviare la credenziale Erasmus (non trovata).")
        return

    # The University of Rennes performs all necessary checks on the Erasmus credential
    print("\nUniversità di Rennes: Ricevuta credenziale Erasmus. Avvio la verifica...")
    if not university_rennes.verify_erasmus_credential(erasmus_cred):
        print("Università di Rennes: ❌ Credenziale Erasmus NON valida. Richiesta respinta.")
        return

    print("Università di Rennes: ✅ Credenziale Erasmus verificata con successo.")

    # Exam entry and Academic VC generation by Rennes
    print("\nUniversità di Rennes: Credenziale Erasmus valida. Procedo con l'emissione della Credenziale Accademica.")
    exams = university_rennes.collect_exam_data() # Rennes loads its own exam data
    if not exams:
        print("Università di Rennes: ⚠️ Nessun esame disponibile per l'emissione della credenziale accademica.")
        return

    university_rennes.generate_academic_credential(student_obj, exams)
    print("Università di Rennes: ✅ Credenziale Accademica emessa.")

    # The student generates the selective presentation
    print("\nStudente: Ora genererò una presentazione selettiva della mia credenziale accademica.")
    student_obj.generate_selective_presentation_from_terminal()


def verify_presentation_at_origin_university(student_obj, university_salerno):
    """
    Handles the verification of a selective presentation by the University of Salerno.
    """
    print("\n==== [ UNIVERSITÀ DI SALERNO - VERIFICA PRESENTATION ] ====")

    if not student_obj:
        print("❌ Oggetto studente non disponibile. Impossibile procedere con la verifica della presentazione.")
        return

    # The student loads their Verifiable Presentation
    path = os.path.join(CRED_FOLDER, f"{student_obj.username}_vp.json")
    try:
        with open(path, "r") as f:
            presentation = json.load(f)
        print(f"Studente: Ho caricato la mia presentazione da {path}.")
    except FileNotFoundError:
        print("❌ Presentazione non trovata. Assicurati di averla generata prima.")
        return
    except json.JSONDecodeError:
        print("❌ Errore di parsing della presentazione.")
        return

    # The University of Salerno verifies the presentation
    print("\nUniversità di Salerno: Ricevuta presentazione. Avvio la verifica...")
    result = university_salerno.verify_selective_presentation(presentation)
    if result:
        print("✅ Presentazione verificata correttamente dall'Università di Salerno.")
    else:
        print("❌ Presentazione NON valida per l'Università di Salerno.")

if __name__ == "__main__":
    # The pre_game phase now returns the authenticated student and university object
    authenticated_student, salerno_university = pre_game()

    if authenticated_student:
        print("\n==== FASE PRE GAME COMPLETATA ====")
        print("LO STUDENTE SI PRESENTA ALL'UNIVERSITÀ OSPITANTE E COMPLETA IL PERCORSO DI STUDIO")
        while True:
            print("\n==== [ MENU PRINCIPALE ] ====")
            print("1. Esci")
            print("2. Richiedi credenziale Erasmus a UniSA") # New option
            print("3. Interagisci con Università di Rennes (Richiedi Attestazione Voti)")
            print("4. Presenta Verifiable Presentation (VP) all'Università di Salerno")
            choice = input("Seleziona un'opzione: ").strip()

            if choice == "1":
                break
            elif choice == "2": # New option handling
                request_erasmus_credential_from_unisa(authenticated_student, salerno_university)
            elif choice == "3":
                rennes_interaction(authenticated_student)
            elif choice == "4":
                verify_presentation_at_origin_university(authenticated_student, salerno_university)
            else:
                print("Opzione non valida.")
    else:
        print("\nImpossibile procedere. Autenticazione iniziale fallita.")
